{"name":"Linux-stackable-file-system-","tagline":"","body":"DIRECTORY STRUCTURE: /usr/src/hw2-ashuklaravis/fs/wrapfs\r\n\r\nApart from the modified wrapfs files, below is a list of the additional files committed:\r\n\r\n    1. kernel.config\r\n    2. pass_key.c (user space program/ioctl)\r\n\t3. wrapfs_ioctl.h\r\n    4. Makefile\r\n    5. readme.txt\r\n\r\nWrapfs Files Modified: \r\n\t\r\n\t1. main.c\r\n\t2. file.c\r\n\t3. lookup.c\r\n\t4. wrapfs.h\r\n\t5. mmap.c\r\n\r\nSTEPS TO COMPILE:\r\n    \r\n    1. make (all/clean)\r\n\t\tBuilds the wrapfs module as well as the pass_key.c\r\n    2. insmod wrapfs.ko\r\n\t3. Mounting Wrapfs:\r\n\t\ta.  Without MMAP option: mount -t wrapfs \"dev_name\" \"mount-point directory\"\r\n\t\tb.  With MMAP option: mount -t wrapfs -o mmap \"dev_name\" \"mount-point directory\"\r\n    4. To run the user space program\r\n                ./pass_key -h : This will show the options and arguments\r\n\r\n       General Scenario:\r\n               ./pass_key -m \"dev_name\" -p \"Password Here\"\r\n\r\nNOTE: I wish I could figure out how to add the -DWRAPFS_CRYPTO to the makefile. Unfortunately, I was unable to do so. So the WRAPFS_CRYPTO option which turns on/off the encryption/decryption has to be changed in the wrapfs.h file. \r\n\r\nDescription:\r\n    \r\n   \t1. User Space Program:\r\n\t\t\r\n\t\t1. In the user space program, gnuopt(3) has been used.\r\n\t\t2. Checks for missing arguments or extra arguments passed. \r\n\t\t3. Removes the '\\n' is used in the password.\r\n\t\t4. Allows passwords of minimum length=6 characters. \r\n\t\t5. A hash of this password is used as the key for encryption/decryption by the file system. Since this hash is of fixed length, it was easier to handle it through out the file system code.\r\n\r\n    2. HASH/ENCRYPTION/DECRYPTION Algorithms:\r\n            \r\n            1. MD5 hash:\r\n                    Used in both User Space and Kernel space.\r\n\r\n                    To use the MD5 Hash, the following openssl packages were\r\n                    downlaoded in user space.\r\n\r\n                     ----------------------------------\r\n                    |NOTE: yum install openssl         |\r\n                    |      yum install openssl-devel   |\r\n                     ----------------------------------\r\n\r\n            2. ceph_aes_encrypt/ceph_aes_decrypt:\r\n\t\t\t\t\r\n\t\t\t\tThe code was taken from Assignment 1 and modified accordingly. \r\n\t\t\t\t\r\n\t\t\t\tBut in this assignment I have used these ciphers are used in Counter Mode. \r\n\t\t\t\tNOTE: Some padding issues were coming up with the CBC mode.\r\n\t\t\t\t\r\n\t\t\t\tmmap information as well as the key are stored in a structure type which is pointed to by the private pointer is the super block. \r\n\t\t\t\tThis way, the key is not present in the persistent memmory.\r\n\t\t\t\t\r\n\t3. Mounting\r\n\t\t\r\n\t\t1. I have followed the code pattern from ecryptfs to parse the mount option. \r\n\t\t2. wrapfs_mount function has been modified. \r\n\t\t3. This modified function basically behaves like nodev function, but with parsing\r\n\t\t4. if an unkown option is passed, filesystem wont be mounted.\r\n\t\t5. As mentioned earlier, mmap information as well as the key are stored in a structure type which is pointed to by the private pointer is the super block. \r\n\t\t   \r\n\t\t\r\n\t\tFile operations assocated with mmap option:\r\n\t\t\r\n\t\tconst struct file_operations wrapfs_mmap_fops = {\r\n\t\t\t.llseek         = generic_file_llseek,\r\n\t\t\t.read           = do_sync_read,\r\n\t\t\t.aio_read       = generic_file_aio_read,\r\n\t\t\t.write          = do_sync_write,\r\n\t\t\t.aio_write      = generic_file_aio_write,\r\n\t\t\t.unlocked_ioctl = wrapfs_unlocked_ioctl,\r\n\t\t\t#ifdef CONFIG_COMPAT\r\n\t\t\t\t.compat_ioctl   = wrapfs_compat_ioctl,\r\n\t\t\t#endif\r\n\t\t\t.mmap           = wrapfs_mmap,\r\n\t\t\t.open           = wrapfs_open,\r\n\t\t\t.flush          = wrapfs_flush,\r\n\t\t\t.release        = wrapfs_file_release,\r\n\t\t\t.fsync          = wrapfs_fsync,\r\n\t\t\t.fasync         = wrapfs_fasync,\r\n\t\t};\r\n\r\n\t\t\r\n\t4. Address Space operations:\r\n\t\r\n\t\t1. Lots of documentation, unionfs source code and ecryptfs source code was used as reference. \r\n\t\t\r\n\t\t2. Address space operation implemented\r\n\t\t\t\r\n\t\t\tconst struct address_space_operations wrapfs_aops = {\r\n\t\t\t\t.writepage = wrapfs_writepage,\r\n\t\t\t\t.readpage = wrapfs_readpage,\r\n\t\t\t\t.write_begin = wrapfs_write_begin,\r\n\t\t\t\t.write_end = wrapfs_write_end\r\n\t\t\t\t};\r\n\r\n\t\t3. unionfs' way of reading is followed. \r\n\t\t\r\n\t\t\tNormal Execution: Wraps calls vfs_read on the lower file system to get the page data. \r\n\t\t\tDecryption: Page data is read from lower file system and then decrypted. \r\n\t\t\r\n\t\t4. ecryptfs' way of writing is followed. \r\n\t\t\t\r\n\t\t\tNormal Execution: Wrapfs issues vfs_write on the lower file system to write the data in the page. \r\n\t\t\tEncryption: Page data is encrypted and then written onto the lower file system. \r\n\t\t\r\n\t\t5.\tSetting/Resetting/Revoking the Key:\r\n\t\r\n\t\t\tI chose to shrink wrapfs's dcache whenever the key was set, revoked, or reset. \r\n\t\t\tThis design decision was made as the pages that were just read with a previous key were still in the cache and readpage would not be called when you would try to read the file with a new key and old contents would be displayed.\r\n\t\t\tTo tackle this security issue, this design decision was made\r\n\r\nNOTE: When No key is given to the file system, it logs a \"NO KEY PRESENT\" message and continues to read and write files with encryption or decryption. \r\n\t\r\nNOTE: I have used macros to debug my code. These macros are turned off. But if erratic behavior is observed, this can be turned on in wrapfs.h\r\nTHIS IS NOT TO BE CONSIDERED FOR EXTRA CREDITS. Also, if these are turned off, I get compile time warnings saying statements which do nothign are present. \r\n\r\nREFERENCES:\r\n    \r\n    1. IOCTL: \r\n        a. http://docs.blackfin.uclinux.org/doku.php?id=linux-kernel:ioctls#ioctl_example_code\r\n\t\tb. http://lists.freebsd.org/pipermail/freebsd-drivers/2005-November/000078.html\r\n    2. Parsing Options: ecryptfs    \r\n    3. readpage, writepage = unionfs\r\n\t4. write_begin, write_end = ecryptfs, unionfs\r\n\t\r\n\t\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}